/*!
 * Exile.js v1.0.0
 * (c) 2018-2018 IMike
 * Released under the MIT License.
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.Exile = factory());
}(this, (function () { 'use strict';

  var DoublyLinkedListNode = function DoublyLinkedListNode(value, next, previous) {
    if ( next === void 0 ) next = null;
    if ( previous === void 0 ) previous = null;

    this.value = value;
    this.next = next;
    this.previous = previous;
  };

  DoublyLinkedListNode.prototype.toString = function toString (callback) {
    return callback ? callback(this.value) : ("" + (this.value));
  };

  var Comparator = function Comparator(compareFn) {
    this.compare = compareFn || Comparator.defaultCompareFn;
  };

  /**
   * @param {(string|number)} a
   * @param {(string|number)} b
   * @returns {number}
   */
  Comparator.defaultCompareFn = function defaultCompareFn (a, b) {
    if (a === b) {
      return 0;
    }

    return a < b ? -1 : 1;
  };

  Comparator.prototype.equal = function equal (a, b) {
    return this.compare(a, b) === 0;
  };

  Comparator.prototype.lessThan = function lessThan (a, b) {
    return this.compare(a, b) < 0;
  };

  Comparator.prototype.greaterThan = function greaterThan (a, b) {
    return this.compare(a, b) > 0;
  };

  Comparator.prototype.lessThanOrEqual = function lessThanOrEqual (a, b) {
    return this.lessThan(a, b) || this.equal(a, b);
  };

  Comparator.prototype.greaterThanOrEqual = function greaterThanOrEqual (a, b) {
    return this.greaterThan(a, b) || this.equal(a, b);
  };

  Comparator.prototype.reverse = function reverse () {
    var compareOriginal = this.compare;
    this.compare = function (a, b) { return compareOriginal(b, a); };
  };

  // 数据结构 ---> 双向链表
  var DoublyLinkedList = function DoublyLinkedList(comparatorFn) {
    this.head = null;
    this.tail = null;
    this.compare = new Comparator(comparatorFn);
  };

  DoublyLinkedList.prototype.prepend = function prepend (value) {
    var newNode = new DoublyLinkedListNode(value, this.head);

    if (this.head) {
      this.head.previous = newNode;
    }
    this.head = newNode;

    if (!this.tail) {
      this.tail = newNode;
    }

    return this;
  };

  DoublyLinkedList.prototype.append = function append (value) {
    var newNode = new DoublyLinkedListNode(value);

    if (!this.head) {
      this.head = newNode;
      this.tail = newNode;

      return this;
    }

    this.tail.next = newNode;

    newNode.previous = this.tail;

    this.tail = newNode;

    return this;
  };

  DoublyLinkedList.prototype.delete = function delete$1 (value) {
      var this$1 = this;

    if (!this.head) {
      return null;
    }

    var deletedNode = null;
    var currentNode = this.head;

    while (currentNode) {
      if (this$1.compare.equal(currentNode.value, value)) {
        deletedNode = currentNode;

        if (deletedNode === this$1.head) {
          this$1.head = deletedNode.next;

          if (this$1.head) {
            this$1.head.previous = null;
          }

          if (deletedNode === this$1.tail) {
            this$1.tail = null;
          }
        } else if (deletedNode === this$1.tail) {
          this$1.tail = deletedNode.previous;
          this$1.tail.next = null;
        } else {
          var previousNode = deletedNode.previous;
          var nextNode = deletedNode.next;

          previousNode.next = nextNode;
          nextNode.previous = previousNode;
        }
      }

      currentNode = currentNode.next;
    }

    return deletedNode;
  };

  DoublyLinkedList.prototype.find = function find (ref) {
      var this$1 = this;
      var value = ref.value; if ( value === void 0 ) value = undefined;
      var callback = ref.callback; if ( callback === void 0 ) callback = undefined;

    if (!this.head) {
      return null;
    }

    var currentNode = this.head;

    while (currentNode) {
      if (callback && callback(currentNode.value)) {
        return currentNode;
      }

      if (value !== undefined && this$1.compare.equal(currentNode.value, value)) {
        return currentNode;
      }

      currentNode = currentNode.next;
    }

    return null;
  };

  DoublyLinkedList.prototype.deleteTail = function deleteTail () {
    if (!this.tail) {
      return null;
    }

    if (this.head === this.tail) {
      var deletedTail$1 = this.tail;
      this.head = null;
      this.tail = null;

      return deletedTail$1
    }

    var deletedTail = this.tail;

    this.tail = this.tail.previous;
    this.tail.next = null;

    return deletedTail;
  };

  DoublyLinkedList.prototype.deleteHead = function deleteHead () {
    if (!this.head) {
      return null;
    }

    var deletedHead = this.head;

    if (this.head.next) {
      this.head = this.head.next;
      this.head.previous = null;
    } else {
      this.head = null;
      this.tail = null;
    }

    return deletedHead;
  };

  DoublyLinkedList.prototype.toArray = function toArray () {
    var nodes = [];

    var currentNode = this.head;
    while (currentNode) {
      nodes.push(currentNode);
      currentNode = currentNode.next;
    }

    return nodes;
  };

  DoublyLinkedList.prototype.fromArray = function fromArray (values) {
      var this$1 = this;

    values.forEach(function (value) { return this$1.append(value); });

    return this;
  };

  DoublyLinkedList.prototype.toString = function toString (callback) {
    return this.toArray().map(function (node) { return node.toString(callback); }).toString();
  };

  var LinkedListNode = function LinkedListNode(value, next) {
    if ( next === void 0 ) next = null;

    this.value = value;
    this.next = next;
  };

  LinkedListNode.prototype.toString = function toString (callback) {
    return callback ? callback(this.value) : ("" + (this.value));
  };

  // 数据结构 ---> 链表
  var LinkedList = function LinkedList(comparatorFn) {
    /** @var LinkedListNode */
    // 链表头部
    this.head = null;

    /** @var LinkedListNode */
    // 链表尾部
    this.tail = null;

    this.compare = new Comparator(comparatorFn);
  };

  /**
   * 向链表头部添加（往前添加节点）
   *
   * @param {*} value （节点值）
   * @return {LinkedList}
   */
  LinkedList.prototype.prepend = function prepend (value) {
    // 让新节点成为头部节点
    var newNode = new LinkedListNode(value, this.head);
    this.head = newNode;

    // 如果没有为节点（即链表中没有任何节点），让新节点成为尾节点
    if (!this.tail) {
      this.tail = newNode;
    }

    return this;
  };

  /**
   * 向链表尾部添加节点
   *
   * @param {*} value
   * @return {LinkedList}
   */
  LinkedList.prototype.append = function append (value) {
    var newNode = new LinkedListNode(value);

    // 如果没有头部节点（即链表中没有任何节点），使新节点成为头部节点以及尾部节点
    if (!this.head) {
      this.head = newNode;
      this.tail = newNode;

      return this;
    }

    // 向链表尾部添加节点
    this.tail.next = newNode;
    this.tail = newNode;

    return this;
  };

  /**
   * 根据节点的值， 删除节点, 返回删除的节点
   *
   * @param {*} value
   * @return {LinkedListNode}
   */
  LinkedList.prototype.delete = function delete$1 (value) {
      var this$1 = this;

    // 如果没有头部节点时，即链表为空， 返回 null
    if (!this.head) {
      return null;
    }

    var deletedNode = null;

    // 如果删除的是头部节点的，即将头部节点设置成原头部节点的下一个节点
    while (this.head && this.compare.equal(this.head.value, value)) {
      deletedNode = this$1.head;
      this$1.head = this$1.head.next;
    }

    var currentNode = this.head;

    if (currentNode !== null) {
      // 遍历整个链表
      // 如果要删除此节点的下一个节点， 则设置此节点的下一个节点为下一个节点的下一个节点
      while (currentNode.next) {
        if (this$1.compare.equal(currentNode.next.value, value)) {
          deletedNode = currentNode.next;
          currentNode.next = currentNode.next.next;
        } else {
          currentNode = currentNode.next;
        }
      }
    }

    // 如果删除的是尾部节点
    if (this.compare.equal(this.tail.value, value)) {
      this.tail = currentNode;
    }

    return deletedNode;
  };

  /**
   * 根据节点的值，以及自定义查找函数， 来查询节点, 并返回查询到的节点
   *
   * @param {Object} findParams
   * @param {*} findParams.value
   * @param {function} [findParams.callback]
   * @return {LinkedListNode}
   */
  LinkedList.prototype.find = function find (ref) {
      var this$1 = this;
      var value = ref.value; if ( value === void 0 ) value = undefined;
      var callback = ref.callback; if ( callback === void 0 ) callback = undefined;

    if (!this.head) {
      return null;
    }

    var currentNode = this.head;

    while (currentNode) {
      // 如果指定了回调，则尝试通过回调查找节点
      if (callback && callback(currentNode.value)) {
        return currentNode;
      }

      // 如果指定了值， 则通过按值比较
      if (value !== undefined && this$1.compare.equal(currentNode.value, value)) {
        return currentNode;
      }

      currentNode = currentNode.next;
    }

    return null;
  };

  /**
   * 删除尾部节点, 并返回尾部节点
   *
   * @return {LinkedListNode}
   */
  LinkedList.prototype.deleteTail = function deleteTail () {
    var deletedTail = this.tail;

    // 如果链表中只有一个节点时
    if (this.head === this.tail) {
      this.head = null;
      this.tail = null;

      return deletedTail;
    }

    // 如果链表中有多个节点，回退到最后一个节点，并且删除最后一个节点之前的next链接
    var currentNode = this.head;
    while (currentNode.next) {
      if (!currentNode.next.next) {
        currentNode.next = null;
      } else {
        currentNode = currentNode.next;
      }
    }

    this.tail = currentNode;

    return deletedTail;
  };

  /**
   * 删除链表头部节点， 并且返回头部节点
   *
   * @return {LinkedListNode}
   */
  LinkedList.prototype.deleteHead = function deleteHead () {
    if (!this.head) {
      return null;
    }

    var deletedHead = this.head;

    if (this.head.next) {
      this.head = this.head.next;
    } else {
      this.head = null;
      this.tail = null;
    }

    return deletedHead;
  };

  /**
   * 将数组转换成链表
   *
   * @param {*[]} values 需要转换成链表的数组
   * @return {LinkedList}
   */
  LinkedList.prototype.fromArray = function fromArray (values) {
      var this$1 = this;

    values.forEach(function (value) { return this$1.append(value); });

    return this;
  };

  /**
   * 将链表转化成数组，并返回节点数组
   *
   * @return {LinkedListNode[]}
   */
  LinkedList.prototype.toArray = function toArray () {
    var nodes = [];

    var currentNode = this.head;
    while (currentNode) {
      nodes.push(currentNode);
      currentNode = currentNode.next;
    }

    return nodes;
  };

  /**
   * 将链表转化成数组，并将节点的value toString
   *
   * @param {function} [callback]
   * @return {string}
   */
  LinkedList.prototype.toString = function toString (callback) {
    return this.toArray().map(function (node) { return node.toString(callback); }).toString();
  };

  // 数据结构 ---> 哈希表
  // 哈希表大小直接影响冲突次数。哈希表大小越大，冲突越少。为了演示目的，哈希表大小很小，
  // 以显示冲突是如何处理的
  var defaultHashTableSize = 32;

  var HashTable = function HashTable(hashTableSize) {
    if ( hashTableSize === void 0 ) hashTableSize = defaultHashTableSize;

    // 创建一定大小的哈希表，并用空链表填充每个桶
    this.buckets = Array(hashTableSize).fill(null).map(function () { return new LinkedList(); });

    // 只是为了快速跟踪所有实际的密钥
    this.keys = {};
  };

  /**
   * 将键字符串转换为哈希值
   * @param {string} key
   * @return {number}
   */
  HashTable.prototype.hash = function hash (key) {
    /**
     * 为了简单起见， 我们将使用密钥的所有字符的字符代码和来计算哈希值
     * 但是你也可以使用更复杂的方法， 如多项式字符串哈希来减少碰撞次数：
     *
     * hash = charCodeAt(0) * PRIME^(n-1) + charCodeAt(1) * PRIME^(n-2) + .. + charCodeAt(n-1)
     *
     * 其中 charCodeAt(i) 是键的第i葛字符代码，n是键的长度和，PRIME 只是像 31 这样的素数
     */
    var hash = Array.from(key).reduce(
      function (hashAccumulator, keySymbol) { return (hashAccumulator + keySymbol.charCodeAt(0)); },
      0
    );

    // 减少哈希值，使其适合哈希表大小
    return hash % this.buckets.length;
  };

  HashTable.prototype.set = function set (key, value) {
    var keyHash = this.hash(key);
    this.keys[key] = keyHash;
    var bucketLinkedList = this.buckets[keyHash];
    var node = bucketLinkedList.find({ callback: function (nodeValue) { return nodeValue.key === key; } });

    if (!node) {
      // 添加新的节点
      bucketLinkedList.append({ key: key, value: value });
    } else {
      // 更新节点的值
      node.value.value = value;
    }
  };

  HashTable.prototype.delete = function delete$1 (key) {
    var keyHash = this.hash(key);
    delete this.keys[key];
    var bucketLinkedList = this.buckets[keyHash];
    var node = bucketLinkedList.find({ callback: function (nodeValue) { return nodeValue.key === key; } });

    if (node) {
      return bucketLinkedList.delete(node.value);
    }

    return null;
  };

  HashTable.prototype.get = function get (key) {
    var bucketLinkedList = this.buckets[this.hash(key)];
    var node = bucketLinkedList.find({ callback: function (nodeValue) { return nodeValue.key === key; } });

    return node ? node.value.value : undefined;
  };

  HashTable.prototype.has = function has (key) {
    return Object.hasOwnProperty.call(this.keys, key);
  };

  HashTable.prototype.getKeys = function getKeys () {
    return Object.keys(this.keys);
  };

  // 数据结构 ---> 堆（最小堆）
  var MinHeap = function MinHeap(comparatorFn) {
    this.heapContainer = [];
    this.compare = new Comparator(comparatorFn);
  };

  /**
   * 根据 parentIndex 获取左侧子节点的 index
   * @param {number} parentIndex
   * @return {number}
   */
  MinHeap.prototype.getLeftChildIndex = function getLeftChildIndex (parentIndex) {
    return (2 * parentIndex) + 1;
  };

  /**
   * 根据 parentIndex 获取右侧子节点的 index
   * @param {number} parentIndex
   * @return {number}
   */
  MinHeap.prototype.getRightChildIndex = function getRightChildIndex (parentIndex) {
    return (2 * parentIndex) + 2;
  };

  /**
   * 根据子节点的 index 获取父节点的 index
   *
   * @param {number} childIndex
   * @returns {number}
   * @memberof MinHeap
   */
  MinHeap.prototype.getParentIndex = function getParentIndex (childIndex) {
    return Math.floor((childIndex - 1) / 2);
  };

  /**
   * 判断是否有父节点
   *
   * @param {number} childIndex
   * @returns {boolean}
   * @memberof MinHeap
   */
  MinHeap.prototype.hasParent = function hasParent (childIndex) {
    return this.getParentIndex(childIndex) >= 0;
  };

  MinHeap.prototype.hasLeftChild = function hasLeftChild (parentIndex) {
    return this.getLeftChildIndex(parentIndex) < this.heapContainer.length;
  };

  MinHeap.prototype.hasRightChild = function hasRightChild (parentIndex) {
    return this.getRightChildIndex(parentIndex) < this.heapContainer.length;
  };

  MinHeap.prototype.leftChild = function leftChild (parentIndex) {
    return this.heapContainer[this.getLeftChildIndex(parentIndex)];
  };

  MinHeap.prototype.rightChild = function rightChild (parentIndex) {
    return this.heapContainer[this.getRightChildIndex(parentIndex)];
  };

  MinHeap.prototype.parent = function parent (childIndex) {
    return this.heapContainer[this.getParentIndex(childIndex)];
  };

  MinHeap.prototype.swap = function swap (indexOne, indexTwo) {
    var tmp = this.heapContainer[indexTwo];
    this.heapContainer[indexTwo] = this.heapContainer[indexOne];
    this.heapContainer[indexOne] = tmp;
  };

  MinHeap.prototype.peek = function peek () {
    if (this.heapContainer.length === 0) {
      return null;
    }

    return this.heapContainer[0];
  };

  MinHeap.prototype.poll = function poll () {
    if (this.heapContainer.length === 0) {
      return null;
    }

    if (this.heapContainer.length === 1) {
      return this.heapContainer.pop();
    }

    var item = this.heapContainer[0];

    // 将最后一个元素移动到头部
    this.heapContainer[0] = this.heapContainer.pop();
    this.heapifyDown();

    return item;
  };

  MinHeap.prototype.add = function add (item) {
    this.heapContainer.push(item);
    this.heapifyUp();

    return this;
  };

  MinHeap.prototype.remove = function remove (item, customFindingComparator) {
      var this$1 = this;

    // 找到需要删除的下标
    var customComparator = customFindingComparator || this.compare;
    var numberOfItemsToRemove = this.find(item, customComparator).length;

    for (var iteration = 0; iteration < numberOfItemsToRemove; iteration += 1) {
      // 我们需要在移除后的每个时间点重新找到项目索引， 因为在 heapif 后索引都在发生变化
      var indexToRemove = this$1.find(item, customComparator).pop();

      // 如果我们需要删除最后一个节点，直接删除，不需要重新 heapif
      if (indexToRemove === (this$1.heapContainer.length - 1)) {
        this$1.heapContainer.pop();
      } else {
        // 将堆容器中的最后一个节点移动到被删除的位置
        this$1.heapContainer[indexToRemove] = this$1.heapContainer.pop();

        // 获取父节点
        var parentItem = this$1.hasParent(indexToRemove) ? this$1.parent(indexToRemove) : null;
        var leftChild = this$1.hasLeftChild(indexToRemove) ? this$1.leftChild(indexToRemove) : null;

        // 如果没有父节点或者父节点小于要删除的节点， 则 heapifDown, 否则 heapifUp
        if (
          leftChild !== null &&
          (
            parentItem === null ||
            this$1.compare.lessThan(parentItem, this$1.heapContainer[indexToRemove])
          )
        ) {
          this$1.heapifyDown(indexToRemove);
        } else {
          this$1.heapifyUp(indexToRemove);
        }
      }
    }

    return this;
  };

  MinHeap.prototype.find = function find (item, customComparator) {
      var this$1 = this;

    var foundItemIndices = [];
    var comparator = customComparator || this.compare;

    for (var itemIndex = 0, len = this.heapContainer.length; itemIndex < len; itemIndex += 1) {
      if (comparator.equal(item, this$1.heapContainer[itemIndex])) {
        foundItemIndices.push(itemIndex);
      }
    }

    return foundItemIndices;
  };

  MinHeap.prototype.heapifyUp = function heapifyUp (customStartIndex) {
      var this$1 = this;

    // 在堆容器中获取最后一个元素（最后一个数组或树的左下角），并将其提升，
    // 直到找到父元素小于当前的父元素为止。
    var currentIndex = customStartIndex || this.heapContainer.length - 1;

    while (
      this.hasParent(currentIndex)
      && this.compare.lessThan(this.heapContainer[currentIndex], this.parent(currentIndex))
    ) {
      this$1.swap(currentIndex, this$1.getParentIndex(currentIndex));
      currentIndex = this$1.getParentIndex(currentIndex);
    }
  };

  MinHeap.prototype.heapifyDown = function heapifyDown (customStartIndex) {
      var this$1 = this;

    // 将根元素与其子元素进行比较， 并将root与子节点中最小的交换， 然后依次对子节点做同样的事情
    var currentIndex = customStartIndex || 0;
    var nextIndex = null;

    while (this.hasLeftChild(currentIndex)) {
      if (
        this$1.hasRightChild(currentIndex)
        && this$1.compare.lessThan(this$1.rightChild(currentIndex), this$1.leftChild(currentIndex))
      ) {
        nextIndex = this$1.getRightChildIndex(currentIndex);
      } else {
        nextIndex = this$1.getLeftChildIndex(currentIndex);
      }

      // 父节点比任何一个子节点都小的时候结束循坏
      if (this$1.compare.lessThan(this$1.heapContainer[currentIndex], this$1.heapContainer[nextIndex])) {
        break;
      }

      this$1.swap(currentIndex, nextIndex);
      currentIndex = nextIndex;
    }
  };

  MinHeap.prototype.isEmpty = function isEmpty () {
    return !this.heapContainer.length;
  };

  MinHeap.prototype.toString = function toString () {
    return this.heapContainer.toString();
  };

  // 数据结构 ---> 优先队列
  // 它与 minHeap 堆相同，除了元素比较时，我们考虑的不是元素的值
  // 而是它的优先级
  var PriorityQueue = (function (MinHeap$$1) {
    function PriorityQueue() {
      MinHeap$$1.call(this);
      this.priorities = {};
      this.compare = new Comparator(this.comparePriority.bind(this));
    }

    if ( MinHeap$$1 ) PriorityQueue.__proto__ = MinHeap$$1;
    PriorityQueue.prototype = Object.create( MinHeap$$1 && MinHeap$$1.prototype );
    PriorityQueue.prototype.constructor = PriorityQueue;

    PriorityQueue.prototype.add = function add (item, priority) {
      if ( priority === void 0 ) priority = 0;

      this.priorities[item] = priority;
      MinHeap$$1.prototype.add.call(this, item);

      return this;
    };

    PriorityQueue.prototype.remove = function remove (item, customFindingComparator) {
      MinHeap$$1.prototype.remove.call(this, item, customFindingComparator);
      delete this.priorities[item];

      return this;
    };

    PriorityQueue.prototype.changePriority = function changePriority (item, priority) {
      this.remove(item, new Comparator(this.compareValue));
      this.add(item, priority);

      return this;
    };

    PriorityQueue.prototype.findByValue = function findByValue (item) {
      return this.find(item, new Comparator(this.compareValue));
    };

    PriorityQueue.prototype.hasValue = function hasValue (item) {
      return this.findByValue(item).length > 0;
    };

    PriorityQueue.prototype.comparePriority = function comparePriority (a, b) {
      if (this.priorities[a] === this.priorities[b]) {
        return 0;
      }

      return this.priorities[a] < this.priorities[b] ? -1 : 1;
    };

    PriorityQueue.prototype.compareValue = function compareValue (a, b) {
      if (a === b) {
        return 0;
      }

      return a < b ? -1 : 1;
    };

    return PriorityQueue;
  }(MinHeap));

  // 数据结构 ---> 队列
  var Queue = function Queue() {
    this.LinkedList = new LinkedList();
  };

  Queue.prototype.isEmpty = function isEmpty () {
    return !this.LinkedList.tail;
  };

  /**
   * 取出队列的第一个值
   */
  Queue.prototype.peek = function peek () {
    if (!this.LinkedList.head) {
      return null;
    }

    return this.LinkedList.head.value;
  };

  /**
   * 向队列中添加元素
   *
   * @param {*} value
   * @memberof Queue
   */
  Queue.prototype.enqueue = function enqueue (value) {
    this.LinkedList.append(value);
  };

  Queue.prototype.dequeue = function dequeue () {
    var removedHead = this.LinkedList.deleteHead();

    return removedHead ? removedHead.value : null;
  };

  Queue.prototype.toString = function toString (callback) {
    return this.LinkedList.toString(callback);
  };

  // 数据结构 ---> 栈
  var Stack = function Stack() {
    this.linkedList = new LinkedList();
  };

  Stack.prototype.isEmpty = function isEmpty () {
    return !this.linkedList.tail;
  };

  Stack.prototype.peek = function peek () {
    if (this.isEmpty()) {
      return null;
    }

    return this.linkedList.tail.value;
  };

  Stack.prototype.push = function push (value) {
    this.linkedList.append(value);
  };

  Stack.prototype.pop = function pop () {
    var removedTail = this.linkedList.deleteTail();
    return removedTail ? removedTail.value : null;
  };

  Stack.prototype.toArray = function toArray () {
    return this.linkedList
      .toArray()
      .map(function (node) { return node.value; })
      .reverse();
  };

  Stack.prototype.toString = function toString (callback) {
    return this.linkedList.toString(callback);
  };

  var TrieNode = function TrieNode(character, isCompleteWord) {
    if ( isCompleteWord === void 0 ) isCompleteWord = false;

    this.character = character;
    this.isCompleteWord = isCompleteWord;
    this.children = new HashTable();
  };

  TrieNode.prototype.getChild = function getChild (character) {
    return this.children.get(character);
  };

  TrieNode.prototype.addChild = function addChild (character, isCompleteWord) {
      if ( isCompleteWord === void 0 ) isCompleteWord = false;

    if (!this.children.has(character)) {
      this.children.set(character, new TrieNode(character, isCompleteWord));
    }

    return this.children.get(character);
  };

  TrieNode.prototype.hasChild = function hasChild (character) {
    return this.children.has(character);
  };

  TrieNode.prototype.suggestChildren = function suggestChildren () {
    return [].concat( this.children.getKeys() );
  };

  TrieNode.prototype.toString = function toString () {
    var childrenAsString = this.suggestChildren().toString();
    childrenAsString = childrenAsString ? (":" + childrenAsString) : '';
    var isCompleteString = this.isCompleteWord ? '*' : '';

    return ("" + (this.character) + isCompleteString + childrenAsString);
  };

  // 数据结构 ---> 字典树
  // 使用 * 作为字典树的根字符
  var HEAD_CHARACTER = '*';

  var Trie = function Trie() {
    this.head = new TrieNode(HEAD_CHARACTER);
  };

  Trie.prototype.addWord = function addWord (word) {
    var characters = Array.from(word);
    var currentNode = this.head;

    for (var charIndex = 0, len = characters.length; charIndex < len; charIndex += 1) {
      var isComplete = charIndex === characters.length - 1;
      currentNode = currentNode.addChild(characters[charIndex], isComplete);
    }

    return this;
  };

  Trie.prototype.suggestNextCharacters = function suggestNextCharacters (word) {
    var lastCharacter = this.getLastCharacterNode(word);

    if (!lastCharacter) {
      return null;
    }

    return lastCharacter.suggestChildren();
  };

  Trie.prototype.doesWordExist = function doesWordExist (word) {
    return !!this.getLastCharacterNode(word);
  };

  Trie.prototype.getLastCharacterNode = function getLastCharacterNode (word) {
    var characters = Array.from(word);
    var currentNode = this.head;

    for (var charIndex = 0, len = characters.length; charIndex < len; charIndex += 1) {
      if (!currentNode.hasChild(characters[charIndex])) {
        return null;
      }

      currentNode = currentNode.getChild(characters[charIndex]);
    }

    return currentNode;
  };

  var Exile = {
    DoublyLinkedList: DoublyLinkedList,
    HashTable: HashTable,
    MinHeap: MinHeap,
    LinkedList: LinkedList,
    PriorityQueue: PriorityQueue,
    Queue: Queue,
    Stack: Stack,
    Trie: Trie,
  };

  return Exile;

})));
